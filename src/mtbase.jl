# This file was formerly a part of Julia. License is MIT: https://julialang.org/license

import Base.trailingsize
import LinearAlgebra.BLAS

function _zeropad!(
    padded::AbstractVector, u::AbstractVector, ::Tuple{Base.OneTo{Int}}
)
    datasize = length(u)
    # Use axes to accommodate arrays that do not start at index 1
    padsize = length(padded)
    data_first_i = first(axes(u, 1))
    copyto!(padded, 1, u, data_first_i, datasize)
    padded[1 + datasize:padsize] .= 0

    padded
end

function _zeropad!(
    padded::AbstractVector, u::AbstractVector, pad_axes
)
    datasize = length(u)
    # Use axes to accommodate arrays that do not start at index 1
    data_first_i = first(axes(u, 1))
    pad_first_i = first(pad_axes[1])
    copyto!(padded, pad_first_i, u, data_first_i, datasize)
    padded[pad_first_i + datasize : last(pad_axes[1])] .= 0

    padded
end

function _zeropad!(
    padded::AbstractArray{<:Any, N},
    u::AbstractArray{<:Any, N},
    ::NTuple{<:Any, Base.OneTo{Int}}
) where N
    # Copy the data to the beginning of the padded array
    fill!(padded, zero(eltype(padded)))
    pad_data_ranges = UnitRange.(1, size(u))
    copyto!(padded, CartesianIndices(pad_data_ranges), u, CartesianIndices(u))

    padded
end

function _zeropad!(
    padded::AbstractArray{<:Any, N},
    u::AbstractArray{<:Any, N},
    pad_axes
) where N
    # Copy the data to the beginning of the padded array
    fill!(padded, zero(eltype(padded)))
    pad_first_i = first.(pad_axes)
    pad_data_ranges = UnitRange.(pad_first_i, pad_first_i .+ size(u) .- 1)
    copyto!(padded, CartesianIndices(pad_data_ranges), u, CartesianIndices(u))

    padded
end

_zeropad!(padded, u) = _zeropad!(padded, u, axes(padded))

function _zeropad(u, padded_size)
    _zeropad!(similar(u, padded_size), u)
end

function _zeropad_keep_offset(u, padded_size, ::NTuple{<:Any, Base.OneTo{Int}})
    _zeropad(u, padded_size)
end

function _zeropad_keep_offset(u, padded_size, axes_u)
    ax_starts = first.(axes_u)
    new_axes = UnitRange.(ax_starts, ax_starts .+ padded_size .- 1)
    _zeropad!(similar(u, new_axes), u, new_axes)
end

_zeropad_keep_offset(u, padded_size) = _zeropad_keep_offset(
    u, padded_size, axes(u)
)

function _conv(
    u::AbstractArray{T, N}, v::AbstractArray{T, N}, paddims
) where {T<:Real, N}
    padded = _zeropad(u, paddims)
    p = plan_rfft(padded)
    uf = p * padded
    _zeropad!(padded, v)
    vf = p * padded
    uf .*= vf
    irfft(uf, paddims[1])
end

function _conv(u, v, paddims)
    upad    = _zeropad(u, paddims)
    vpad    = _zeropad(v, paddims)
    p!      = plan_fft!(upad)
    p! * upad # Operates in place on upad
    p! * vpad
    upad .*= vpad
    ifft!(upad)
end

function _conv_clip!(
    y::AbstractVector,
    minpad,
    ::NTuple{<:Any, Base.OneTo{Int}},
    ::NTuple{<:Any, Base.OneTo{Int}}
)
    sizehint!(resize!(y, minpad[1]), minpad[1])
end

function _conv_clip!(
    y::AbstractArray,
    minpad,
    ::NTuple{<:Any, Base.OneTo{Int}},
    ::NTuple{<:Any, Base.OneTo{Int}}
)
    y[CartesianIndices(minpad)]
end

# For arrays with weird offsets
function _conv_clip!(y::AbstractArray, minpad, axesu, axesv)
    out_offsets = first.(axesu) .+ first.(axesv)
    out_axes    = UnitRange.(out_offsets, out_offsets .+ minpad .- 1)
    out         = similar(y, out_axes)
    copyto!(out, CartesianIndices(out), y, CartesianIndices(UnitRange.(1, minpad)))
end

"""
    conv(u,v)

Convolution of two arrays. Uses FFT algorithm.
"""
function conv(u::AbstractArray{T, N},
              v::AbstractArray{T, N}) where {T<:BLAS.BlasFloat, N}
    su      = size(u)
    sv      = size(v)
    minpad  = su .+ sv .- 1
    padsize = map(n -> n > 1024 ? nextprod([2,3,5], n) : nextpow(2, n), minpad)
    y       = _conv(u, v, padsize)
    _conv_clip!(y, minpad, axes(u), axes(v))
end
function conv(u::AbstractArray{<:BLAS.BlasFloat, N},
              v::AbstractArray{<:BLAS.BlasFloat, N}) where N
    fu, fv = promote(u, v)
    conv(fu, fv)
end

conv(u::AbstractArray{T, N}, v::AbstractArray{T, N}) where {T<:Number, N} =
    conv(float(u), float(v))

conv(u::AbstractArray{<:Integer, N}, v::AbstractArray{<:Integer, N}) where {N} =
    round.(Int, conv(float(u), float(v)))

function conv(u::AbstractArray{<:Number, N},
              v::AbstractArray{<:BLAS.BlasFloat, N}) where N
    conv(float(u), v)
end

function conv(u::AbstractArray{<:BLAS.BlasFloat, N},
              v::AbstractArray{<:Number, N}) where N
    conv(u, float(v))
end

function conv(A::AbstractArray, B::AbstractArray)
    maxnd = max(ndims(A), ndims(B))
    return conv(cat(A, dims=maxnd), cat(B, dims=maxnd))
end

"""
    conv(u,v,A)

2-D convolution of the matrix `A` with the 2-D separable kernel generated by
the vectors `u` and `v`.
Uses 2-D FFT algorithm.
"""
function conv(u::AbstractVector{T}, v::AbstractVector{T}, A::AbstractMatrix{T}) where T
    # Arbitrary indexing offsets not implemented
    @assert !Base.has_offset_axes(u, v, A)
    m = length(u)+size(A,1)-1
    n = length(v)+size(A,2)-1
    B = zeros(T, m, n)
    B[1:size(A,1),1:size(A,2)] = A
    u = fft([u;zeros(T,m-length(u))])
    v = fft([v;zeros(T,n-length(v))])
    C = ifft(fft(B) .* (u * transpose(v)))
    if T <: Real
        return real(C)
    end
    return C
end

